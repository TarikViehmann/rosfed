diff -urN vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/CHANGELOG.rst cv_bridge.opencv4/CHANGELOG.rst
--- vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/CHANGELOG.rst	2018-04-30 19:54:22.000000000 +0200
+++ cv_bridge.opencv4/CHANGELOG.rst	2020-04-29 14:54:18.112955647 +0200
@@ -2,6 +2,14 @@
 Changelog for package cv_bridge
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
+1.14.0 (2020-04-06)
+-------------------
+* Noetic release (`#323 <https://github.com/ros-perception/vision_opencv/issues/323>`_)
+* update CMakeLists.txt for Windows build environment (`#265 <https://github.com/ros-perception/vision_opencv/issues/265>`_)
+* remove path splash separator from 'package_dir' (`#267 <https://github.com/ros-perception/vision_opencv/issues/267>`_)
+* fix travis. (`#269 <https://github.com/ros-perception/vision_opencv/issues/269>`_)
+* Contributors: Alejandro Hern√°ndez Cordero, James Xu, Sean Yen
+
 1.13.0 (2018-04-30)
 -------------------
 * Use rosdep OpenCV and not ROS one.
diff -urN vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/CMakeLists.txt cv_bridge.opencv4/CMakeLists.txt
--- vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/CMakeLists.txt	2018-04-30 19:54:22.000000000 +0200
+++ cv_bridge.opencv4/CMakeLists.txt	2020-04-29 15:29:11.656732967 +0200
@@ -1,19 +1,15 @@
-cmake_minimum_required(VERSION 2.8)
+cmake_minimum_required(VERSION 3.0.2)
 project(cv_bridge)
 
 find_package(catkin REQUIRED COMPONENTS rosconsole sensor_msgs)
 
 if(NOT ANDROID)
   find_package(PythonLibs)
-  if(PYTHONLIBS_VERSION_STRING VERSION_LESS 3)
-    find_package(Boost REQUIRED python)
-  else()
-    find_package(Boost REQUIRED python3)
-  endif()
+  find_package(Boost REQUIRED python${PYTHON_VERSION_NODOTS})
 else()
 find_package(Boost REQUIRED)
 endif()
-find_package(OpenCV 3 REQUIRED
+find_package(OpenCV 4 REQUIRED
   COMPONENTS
     opencv_core
     opencv_imgproc
diff -urN vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/package.xml cv_bridge.opencv4/package.xml
--- vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/package.xml	2018-04-30 19:54:22.000000000 +0200
+++ cv_bridge.opencv4/package.xml	2020-04-29 14:54:18.113955666 +0200
@@ -1,6 +1,6 @@
 <package format="2">
   <name>cv_bridge</name>
-  <version>1.13.0</version>
+  <version>1.14.0</version>
   <description>
     This contains CvBridge, which converts between ROS
     Image messages and OpenCV images.
@@ -21,21 +21,21 @@
 
   <build_depend>boost</build_depend>
   <build_depend>libopencv-dev</build_depend>
-  <build_depend>python</build_depend>
-  <build_depend>python-opencv</build_depend>
+  <build_depend>python3</build_depend>
+  <build_depend>python3-opencv</build_depend>
   <build_depend>rosconsole</build_depend>
   <build_depend>sensor_msgs</build_depend>
 
   <exec_depend>boost</exec_depend>
   <exec_depend>libopencv-dev</exec_depend>
-  <exec_depend>python</exec_depend>
-  <exec_depend>python-opencv</exec_depend>
+  <exec_depend>python3</exec_depend>
+  <exec_depend>python3-opencv</exec_depend>
   <exec_depend>rosconsole</exec_depend>
   <build_export_depend>libopencv-dev</build_export_depend>
   <build_export_depend>sensor_msgs</build_export_depend>
 
   <test_depend>rostest</test_depend>
-  <test_depend>python-numpy</test_depend>
+  <test_depend>python3-numpy</test_depend>
 
   <doc_depend>dvipng</doc_depend>
 </package>
diff -urN vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/python/cv_bridge/core.py cv_bridge.opencv4/python/cv_bridge/core.py
--- vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/python/cv_bridge/core.py	2018-04-30 19:54:22.000000000 +0200
+++ cv_bridge.opencv4/python/cv_bridge/core.py	2020-04-29 14:54:18.113955666 +0200
@@ -167,8 +167,12 @@
             im = np.ndarray(shape=(img_msg.height, img_msg.width),
                            dtype=dtype, buffer=img_msg.data)
         else:
-            im = np.ndarray(shape=(img_msg.height, img_msg.width, n_channels),
-                           dtype=dtype, buffer=img_msg.data)
+            if(type(img_msg.data) == str):
+                im = np.ndarray(shape=(img_msg.height, img_msg.width, n_channels),
+                               dtype=dtype, buffer=img_msg.data.encode())
+            else:
+                im = np.ndarray(shape=(img_msg.height, img_msg.width, n_channels),
+                               dtype=dtype, buffer=img_msg.data)
         # If the byt order is different between the message and the system.
         if img_msg.is_bigendian == (sys.byteorder == 'little'):
             im = im.byteswap().newbyteorder()
diff -urN vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/setup.py cv_bridge.opencv4/setup.py
--- vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/setup.py	2018-04-30 19:54:22.000000000 +0200
+++ cv_bridge.opencv4/setup.py	2020-04-29 14:54:18.113955666 +0200
@@ -1,5 +1,5 @@
 #!/usr/bin/env python
-from distutils.core import setup
+from setuptools import setup
 from catkin_pkg.python_setup import generate_distutils_setup
 
 d = generate_distutils_setup()
diff -urN vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/src/CMakeLists.txt cv_bridge.opencv4/src/CMakeLists.txt
--- vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/src/CMakeLists.txt	2018-04-30 19:54:22.000000000 +0200
+++ cv_bridge.opencv4/src/CMakeLists.txt	2020-04-29 14:54:18.114955685 +0200
@@ -32,11 +32,7 @@
   add_definitions(-DPYTHON3)
 endif()
 
-if (OpenCV_VERSION_MAJOR VERSION_EQUAL 3)
-add_library(${PROJECT_NAME}_boost module.cpp module_opencv3.cpp)
-else()
-add_library(${PROJECT_NAME}_boost module.cpp module_opencv2.cpp)
-endif()
+add_library(${PROJECT_NAME}_boost module.cpp module_opencv4.cpp)
 target_link_libraries(${PROJECT_NAME}_boost ${Boost_LIBRARIES}
                                             ${catkin_LIBRARIES}
                                             ${PYTHON_LIBRARIES}
diff -urN vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/src/module.hpp cv_bridge.opencv4/src/module.hpp
--- vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/src/module.hpp	2018-04-30 19:54:22.000000000 +0200
+++ cv_bridge.opencv4/src/module.hpp	2020-04-29 14:54:18.114955685 +0200
@@ -33,16 +33,10 @@
 
 PyObject* pyopencv_from(const cv::Mat& m);
 
-#if PYTHON3
-static int do_numpy_import( )
+static void * do_numpy_import( )
 {
     import_array( );
+    return nullptr;
 }
-#else
-static void do_numpy_import( )
-{
-    import_array( );
-}
-#endif
 
 #endif
diff -urN vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/src/module_opencv2.cpp cv_bridge.opencv4/src/module_opencv2.cpp
--- vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/src/module_opencv2.cpp	2018-04-30 19:54:22.000000000 +0200
+++ cv_bridge.opencv4/src/module_opencv2.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,262 +0,0 @@
-/*********************************************************************
-* Software License Agreement (BSD License)
-*
-*  Copyright (c) 2012, Willow Garage, Inc.
-*  All rights reserved.
-*
-*  Redistribution and use in source and binary forms, with or without
-*  modification, are permitted provided that the following conditions
-*  are met:
-*
-*   * Redistributions of source code must retain the above copyright
-*     notice, this list of conditions and the following disclaimer.
-*   * Redistributions in binary form must reproduce the above
-*     copyright notice, this list of conditions and the following
-*     disclaimer in the documentation and/or other materials provided
-*     with the distribution.
-*   * Neither the name of the Willow Garage nor the names of its
-*     contributors may be used to endorse or promote products derived
-*     from this software without specific prior written permission.
-*
-*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-*  POSSIBILITY OF SUCH DAMAGE.
-*********************************************************************/
-
-#include "module.hpp"
-
-using namespace cv;
-
-// These are sucky, sketchy versions of the real things in OpenCV Python,
-// inferior in every way.
-
-static int failmsg(const char *fmt, ...)
-{
-  char str[1000];
-
-  va_list ap;
-  va_start(ap, fmt);
-  vsnprintf(str, sizeof(str), fmt, ap);
-  va_end(ap);
-
-  PyErr_SetString(PyExc_TypeError, str);
-  return 0;
-}
-
-static PyObject* opencv_error = 0;
-
-class PyAllowThreads
-{
-public:
-    PyAllowThreads() : _state(PyEval_SaveThread()) {}
-    ~PyAllowThreads()
-    {
-        PyEval_RestoreThread(_state);
-    }
-private:
-    PyThreadState* _state;
-};
-
-#define ERRWRAP2(expr) \
-try \
-{ \
-    PyAllowThreads allowThreads; \
-    expr; \
-} \
-catch (const cv::Exception &e) \
-{ \
-    PyErr_SetString(opencv_error, e.what()); \
-    return 0; \
-}
-
-// Taken from http://stackoverflow.com/questions/19136944/call-c-opencv-functions-from-python-send-a-cv-mat-to-c-dll-which-is-usi
-
-
-static size_t REFCOUNT_OFFSET = ( size_t )&((( PyObject* )0)->ob_refcnt ) +
-( 0x12345678 != *( const size_t* )"\x78\x56\x34\x12\0\0\0\0\0" )*sizeof( int );
-
-
-static inline PyObject* pyObjectFromRefcount( const int* refcount )
-{
-return ( PyObject* )(( size_t )refcount - REFCOUNT_OFFSET );
-}
-
-static inline int* refcountFromPyObject( const PyObject* obj )
-{
-return ( int* )(( size_t )obj + REFCOUNT_OFFSET );
-}
-
-class NumpyAllocator : public cv::MatAllocator
-{
-public:
-NumpyAllocator( ) { }
-~NumpyAllocator( ) { }
-
-void allocate( int dims, const int* sizes, int type, int*& refcount,
-uchar*& datastart, uchar*& data, size_t* step );
-
-void deallocate( int* refcount, uchar* datastart, uchar* data );
-};
-
-void NumpyAllocator::allocate( int dims, const int* sizes, int type, int*& refcount, uchar*& datastart, uchar*& data, size_t* step )
-{
-    int depth = CV_MAT_DEPTH( type );
-    int cn = CV_MAT_CN( type );
-    const int f = ( int )( sizeof( size_t )/8 );
-    int typenum = depth == CV_8U ? NPY_UBYTE : depth == CV_8S ? NPY_BYTE :
-                  depth == CV_16U ? NPY_USHORT : depth == CV_16S ? NPY_SHORT :
-                  depth == CV_32S ? NPY_INT : depth == CV_32F ? NPY_FLOAT :
-                  depth == CV_64F ? NPY_DOUBLE : f*NPY_ULONGLONG + (f^1)*NPY_UINT;
-    int i;
-    npy_intp _sizes[CV_MAX_DIM+1];
-    for( i = 0; i < dims; i++ )
-        _sizes[i] = sizes[i];
-    if( cn > 1 )
-    {
-    /*if( _sizes[dims-1] == 1 )
-         _sizes[dims-1] = cn;
-    else*/
-        _sizes[dims++] = cn;
-    }
-    PyObject* o = PyArray_SimpleNew( dims, _sizes, typenum );
-    if( !o )
-    CV_Error_(CV_StsError, ("The numpy array of typenum=%d, ndims=%d can not be created", typenum, dims));
-    refcount = refcountFromPyObject(o);
-    npy_intp* _strides = PyArray_STRIDES((PyArrayObject*) o);
-    for( i = 0; i < dims - (cn > 1); i++ )
-        step[i] = (size_t)_strides[i];
-    datastart = data = (uchar*)PyArray_DATA((PyArrayObject*)o);
-
-}
-
-void NumpyAllocator::deallocate( int* refcount, uchar* datastart, uchar* data )
-{
-    if( !refcount )
-       return;
-    PyObject* o = pyObjectFromRefcount(refcount);
-    Py_INCREF(o);
-    Py_DECREF(o);
-}
-
-// Declare the object
-NumpyAllocator g_numpyAllocator;
-
-int convert_to_CvMat2(const PyObject* o, cv::Mat& m)
-{
-    // to avoid PyArray_Check() to crash even with valid array
-    do_numpy_import();
-
-    if(!o || o == Py_None)
-    {
-        if( !m.data )
-            m.allocator = &g_numpyAllocator;
-        return true;
-    }
-
-    if( !PyArray_Check(o) )
-    {
-        failmsg("Not a numpy array");
-        return false;
-    }
-
-    // NPY_LONG (64 bit) is converted to CV_32S (32 bit)
-    int typenum = PyArray_TYPE((PyArrayObject*) o);
-    int type = typenum == NPY_UBYTE ? CV_8U : typenum == NPY_BYTE ? CV_8S :
-        typenum == NPY_USHORT ? CV_16U : typenum == NPY_SHORT ? CV_16S :
-        typenum == NPY_INT || typenum == NPY_LONG ? CV_32S :
-        typenum == NPY_FLOAT ? CV_32F :
-        typenum == NPY_DOUBLE ? CV_64F : -1;
-
-    if( type < 0 )
-    {
-        failmsg("data type = %d is not supported", typenum);
-        return false;
-    }
-
-    int ndims = PyArray_NDIM((PyArrayObject*) o);
-    if(ndims >= CV_MAX_DIM)
-    {
-        failmsg("dimensionality (=%d) is too high", ndims);
-        return false;
-    }
-
-    int size[CV_MAX_DIM+1];
-    size_t step[CV_MAX_DIM+1], elemsize = CV_ELEM_SIZE1(type);
-    const npy_intp* _sizes = PyArray_DIMS((PyArrayObject*) o);
-    const npy_intp* _strides = PyArray_STRIDES((PyArrayObject*) o);
-    bool transposed = false;
-
-    for(int i = 0; i < ndims; i++)
-    {
-        size[i] = (int)_sizes[i];
-        step[i] = (size_t)_strides[i];
-    }
-
-    if( ndims == 0 || step[ndims-1] > elemsize ) {
-        size[ndims] = 1;
-        step[ndims] = elemsize;
-        ndims++;
-    }
-
-    if( ndims >= 2 && step[0] < step[1] )
-    {
-        std::swap(size[0], size[1]);
-        std::swap(step[0], step[1]);
-        transposed = true;
-    }
-
-    if( ndims == 3 && size[2] <= CV_CN_MAX && step[1] == elemsize*size[2] )
-    {
-        ndims--;
-        type |= CV_MAKETYPE(0, size[2]);
-    }
-
-    if( ndims > 2 )
-    {
-        failmsg("more than 2 dimensions");
-        return false;
-    }
-
-    m = cv::Mat(ndims, size, type, PyArray_DATA((PyArrayObject*) o), step);
-
-    if( m.data )
-    {
-        m.refcount = refcountFromPyObject(o);
-        m.addref(); // protect the original numpy array from deallocation
-        // (since Mat destructor will decrement the reference counter)
-    };
-    m.allocator = &g_numpyAllocator;
-
-    if( transposed )
-    {
-        cv::Mat tmp;
-        tmp.allocator = &g_numpyAllocator;
-        transpose(m, tmp);
-        m = tmp;
-    }
-    return true;
-}
-
-PyObject* pyopencv_from(const Mat& m)
-{
-    if( !m.data )
-        Py_RETURN_NONE;
-    Mat temp, *p = (Mat*)&m;
-    if(!p->refcount || p->allocator != &g_numpyAllocator)
-    {
-        temp.allocator = &g_numpyAllocator;
-        ERRWRAP2(m.copyTo(temp));
-        p = &temp;
-    }
-    p->addref();
-    return pyObjectFromRefcount(p->refcount);
-}
diff -urN vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/src/module_opencv3.cpp cv_bridge.opencv4/src/module_opencv3.cpp
--- vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/src/module_opencv3.cpp	2018-04-30 19:54:22.000000000 +0200
+++ cv_bridge.opencv4/src/module_opencv3.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,367 +0,0 @@
-// Taken from opencv/modules/python/src2/cv2.cpp
-
-#include "module.hpp"
-
-#include "opencv2/core/types_c.h"
-
-#include "opencv2/opencv_modules.hpp"
-
-#include "pycompat.hpp"
-
-static PyObject* opencv_error = 0;
-
-static int failmsg(const char *fmt, ...)
-{
-    char str[1000];
-
-    va_list ap;
-    va_start(ap, fmt);
-    vsnprintf(str, sizeof(str), fmt, ap);
-    va_end(ap);
-
-    PyErr_SetString(PyExc_TypeError, str);
-    return 0;
-}
-
-struct ArgInfo
-{
-    const char * name;
-    bool outputarg;
-    // more fields may be added if necessary
-
-    ArgInfo(const char * name_, bool outputarg_)
-        : name(name_)
-        , outputarg(outputarg_) {}
-
-    // to match with older pyopencv_to function signature
-    operator const char *() const { return name; }
-};
-
-class PyAllowThreads
-{
-public:
-    PyAllowThreads() : _state(PyEval_SaveThread()) {}
-    ~PyAllowThreads()
-    {
-        PyEval_RestoreThread(_state);
-    }
-private:
-    PyThreadState* _state;
-};
-
-class PyEnsureGIL
-{
-public:
-    PyEnsureGIL() : _state(PyGILState_Ensure()) {}
-    ~PyEnsureGIL()
-    {
-        PyGILState_Release(_state);
-    }
-private:
-    PyGILState_STATE _state;
-};
-
-#define ERRWRAP2(expr) \
-try \
-{ \
-    PyAllowThreads allowThreads; \
-    expr; \
-} \
-catch (const cv::Exception &e) \
-{ \
-    PyErr_SetString(opencv_error, e.what()); \
-    return 0; \
-}
-
-using namespace cv;
-
-static PyObject* failmsgp(const char *fmt, ...)
-{
-  char str[1000];
-
-  va_list ap;
-  va_start(ap, fmt);
-  vsnprintf(str, sizeof(str), fmt, ap);
-  va_end(ap);
-
-  PyErr_SetString(PyExc_TypeError, str);
-  return 0;
-}
-
-class NumpyAllocator : public MatAllocator
-{
-public:
-    NumpyAllocator() { stdAllocator = Mat::getStdAllocator(); }
-    ~NumpyAllocator() {}
-
-    UMatData* allocate(PyObject* o, int dims, const int* sizes, int type, size_t* step) const
-    {
-        UMatData* u = new UMatData(this);
-        u->data = u->origdata = (uchar*)PyArray_DATA((PyArrayObject*) o);
-        npy_intp* _strides = PyArray_STRIDES((PyArrayObject*) o);
-        for( int i = 0; i < dims - 1; i++ )
-            step[i] = (size_t)_strides[i];
-        step[dims-1] = CV_ELEM_SIZE(type);
-        u->size = sizes[0]*step[0];
-        u->userdata = o;
-        return u;
-    }
-
-    UMatData* allocate(int dims0, const int* sizes, int type, void* data, size_t* step, int flags, UMatUsageFlags usageFlags) const
-    {
-        if( data != 0 )
-        {
-            CV_Error(Error::StsAssert, "The data should normally be NULL!");
-            // probably this is safe to do in such extreme case
-            return stdAllocator->allocate(dims0, sizes, type, data, step, flags, usageFlags);
-        }
-        PyEnsureGIL gil;
-
-        int depth = CV_MAT_DEPTH(type);
-        int cn = CV_MAT_CN(type);
-        const int f = (int)(sizeof(size_t)/8);
-        int typenum = depth == CV_8U ? NPY_UBYTE : depth == CV_8S ? NPY_BYTE :
-        depth == CV_16U ? NPY_USHORT : depth == CV_16S ? NPY_SHORT :
-        depth == CV_32S ? NPY_INT : depth == CV_32F ? NPY_FLOAT :
-        depth == CV_64F ? NPY_DOUBLE : f*NPY_ULONGLONG + (f^1)*NPY_UINT;
-        int i, dims = dims0;
-        cv::AutoBuffer<npy_intp> _sizes(dims + 1);
-        for( i = 0; i < dims; i++ )
-            _sizes[i] = sizes[i];
-        if( cn > 1 )
-            _sizes[dims++] = cn;
-        PyObject* o = PyArray_SimpleNew(dims, _sizes, typenum);
-        if(!o)
-            CV_Error_(Error::StsError, ("The numpy array of typenum=%d, ndims=%d can not be created", typenum, dims));
-        return allocate(o, dims0, sizes, type, step);
-    }
-
-    bool allocate(UMatData* u, int accessFlags, UMatUsageFlags usageFlags) const
-    {
-        return stdAllocator->allocate(u, accessFlags, usageFlags);
-    }
-
-    void deallocate(UMatData* u) const
-    {
-        if(u)
-        {
-            PyEnsureGIL gil;
-            PyObject* o = (PyObject*)u->userdata;
-            Py_XDECREF(o);
-            delete u;
-        }
-    }
-
-    const MatAllocator* stdAllocator;
-};
-
-NumpyAllocator g_numpyAllocator;
-
-
-template<typename T> static
-bool pyopencv_to(PyObject* obj, T& p, const char* name = "<unknown>");
-
-template<typename T> static
-PyObject* pyopencv_from(const T& src);
-
-enum { ARG_NONE = 0, ARG_MAT = 1, ARG_SCALAR = 2 };
-
-// special case, when the convertor needs full ArgInfo structure
-static bool pyopencv_to(PyObject* o, Mat& m, const ArgInfo info)
-{
-      // to avoid PyArray_Check() to crash even with valid array
-    do_numpy_import( );
-
-
-    bool allowND = true;
-    if(!o || o == Py_None)
-    {
-        if( !m.data )
-            m.allocator = &g_numpyAllocator;
-        return true;
-    }
-
-    if( PyInt_Check(o) )
-    {
-        double v[] = {(double)PyInt_AsLong((PyObject*)o), 0., 0., 0.};
-        m = Mat(4, 1, CV_64F, v).clone();
-        return true;
-    }
-    if( PyFloat_Check(o) )
-    {
-        double v[] = {PyFloat_AsDouble((PyObject*)o), 0., 0., 0.};
-        m = Mat(4, 1, CV_64F, v).clone();
-        return true;
-    }
-    if( PyTuple_Check(o) )
-    {
-        int i, sz = (int)PyTuple_Size((PyObject*)o);
-        m = Mat(sz, 1, CV_64F);
-        for( i = 0; i < sz; i++ )
-        {
-            PyObject* oi = PyTuple_GET_ITEM(o, i);
-            if( PyInt_Check(oi) )
-                m.at<double>(i) = (double)PyInt_AsLong(oi);
-            else if( PyFloat_Check(oi) )
-                m.at<double>(i) = (double)PyFloat_AsDouble(oi);
-            else
-            {
-                failmsg("%s is not a numerical tuple", info.name);
-                m.release();
-                return false;
-            }
-        }
-        return true;
-    }
-
-    if( !PyArray_Check(o) )
-    {
-        failmsg("%s is not a numpy array, neither a scalar", info.name);
-        return false;
-    }
-
-    PyArrayObject* oarr = (PyArrayObject*) o;
-
-    bool needcopy = false, needcast = false;
-    int typenum = PyArray_TYPE(oarr), new_typenum = typenum;
-    int type = typenum == NPY_UBYTE ? CV_8U :
-               typenum == NPY_BYTE ? CV_8S :
-               typenum == NPY_USHORT ? CV_16U :
-               typenum == NPY_SHORT ? CV_16S :
-               typenum == NPY_INT ? CV_32S :
-               typenum == NPY_INT32 ? CV_32S :
-               typenum == NPY_FLOAT ? CV_32F :
-               typenum == NPY_DOUBLE ? CV_64F : -1;
-
-    if( type < 0 )
-    {
-        if( typenum == NPY_INT64 || typenum == NPY_UINT64 || type == NPY_LONG )
-        {
-            needcopy = needcast = true;
-            new_typenum = NPY_INT;
-            type = CV_32S;
-        }
-        else
-        {
-            failmsg("%s data type = %d is not supported", info.name, typenum);
-            return false;
-        }
-    }
-
-#ifndef CV_MAX_DIM
-    const int CV_MAX_DIM = 32;
-#endif
-
-    int ndims = PyArray_NDIM(oarr);
-    if(ndims >= CV_MAX_DIM)
-    {
-        failmsg("%s dimensionality (=%d) is too high", info.name, ndims);
-        return false;
-    }
-
-    int size[CV_MAX_DIM+1];
-    size_t step[CV_MAX_DIM+1];
-    size_t elemsize = CV_ELEM_SIZE1(type);
-    const npy_intp* _sizes = PyArray_DIMS(oarr);
-    const npy_intp* _strides = PyArray_STRIDES(oarr);
-    bool ismultichannel = ndims == 3 && _sizes[2] <= CV_CN_MAX;
-
-    for( int i = ndims-1; i >= 0 && !needcopy; i-- )
-    {
-        // these checks handle cases of
-        //  a) multi-dimensional (ndims > 2) arrays, as well as simpler 1- and 2-dimensional cases
-        //  b) transposed arrays, where _strides[] elements go in non-descending order
-        //  c) flipped arrays, where some of _strides[] elements are negative
-        if( (i == ndims-1 && (size_t)_strides[i] != elemsize) ||
-            (i < ndims-1 && _strides[i] < _strides[i+1]) )
-            needcopy = true;
-    }
-
-    if( ismultichannel && _strides[1] != (npy_intp)elemsize*_sizes[2] )
-        needcopy = true;
-
-    if (needcopy)
-    {
-        if (info.outputarg)
-        {
-            failmsg("Layout of the output array %s is incompatible with cv::Mat (step[ndims-1] != elemsize or step[1] != elemsize*nchannels)", info.name);
-            return false;
-        }
-
-        if( needcast ) {
-            o = PyArray_Cast(oarr, new_typenum);
-            oarr = (PyArrayObject*) o;
-        }
-        else {
-            oarr = PyArray_GETCONTIGUOUS(oarr);
-            o = (PyObject*) oarr;
-        }
-
-        _strides = PyArray_STRIDES(oarr);
-    }
-
-    for(int i = 0; i < ndims; i++)
-    {
-        size[i] = (int)_sizes[i];
-        step[i] = (size_t)_strides[i];
-    }
-
-    // handle degenerate case
-    if( ndims == 0) {
-        size[ndims] = 1;
-        step[ndims] = elemsize;
-        ndims++;
-    }
-
-    if( ismultichannel )
-    {
-        ndims--;
-        type |= CV_MAKETYPE(0, size[2]);
-    }
-
-    if( ndims > 2 && !allowND )
-    {
-        failmsg("%s has more than 2 dimensions", info.name);
-        return false;
-    }
-
-    m = Mat(ndims, size, type, PyArray_DATA(oarr), step);
-    m.u = g_numpyAllocator.allocate(o, ndims, size, type, step);
-    m.addref();
-
-    if( !needcopy )
-    {
-        Py_INCREF(o);
-    }
-    m.allocator = &g_numpyAllocator;
-
-    return true;
-}
-
-template<>
-bool pyopencv_to(PyObject* o, Mat& m, const char* name)
-{
-    return pyopencv_to(o, m, ArgInfo(name, 0));
-}
-
-PyObject* pyopencv_from(const Mat& m)
-{
-    if( !m.data )
-        Py_RETURN_NONE;
-    Mat temp, *p = (Mat*)&m;
-    if(!p->u || p->allocator != &g_numpyAllocator)
-    {
-        temp.allocator = &g_numpyAllocator;
-        ERRWRAP2(m.copyTo(temp));
-        p = &temp;
-    }
-    PyObject* o = (PyObject*)p->u->userdata;
-    Py_INCREF(o);
-    return o;
-}
-
-int convert_to_CvMat2(const PyObject* o, cv::Mat& m)
-{
-    pyopencv_to(const_cast<PyObject*>(o), m, "unknown");
-    return 0;
-}
diff -urN vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/src/module_opencv4.cpp cv_bridge.opencv4/src/module_opencv4.cpp
--- vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/src/module_opencv4.cpp	1970-01-01 01:00:00.000000000 +0100
+++ cv_bridge.opencv4/src/module_opencv4.cpp	2020-04-29 14:54:18.114955685 +0200
@@ -0,0 +1,367 @@
+// Taken from opencv/modules/python/src2/cv2.cpp
+
+#include "module.hpp"
+
+#include "opencv2/core/types_c.h"
+
+#include "opencv2/opencv_modules.hpp"
+
+#include "pycompat.hpp"
+
+static PyObject* opencv_error = 0;
+
+static int failmsg(const char *fmt, ...)
+{
+    char str[1000];
+
+    va_list ap;
+    va_start(ap, fmt);
+    vsnprintf(str, sizeof(str), fmt, ap);
+    va_end(ap);
+
+    PyErr_SetString(PyExc_TypeError, str);
+    return 0;
+}
+
+struct ArgInfo
+{
+    const char * name;
+    bool outputarg;
+    // more fields may be added if necessary
+
+    ArgInfo(const char * name_, bool outputarg_)
+        : name(name_)
+        , outputarg(outputarg_) {}
+
+    // to match with older pyopencv_to function signature
+    operator const char *() const { return name; }
+};
+
+class PyAllowThreads
+{
+public:
+    PyAllowThreads() : _state(PyEval_SaveThread()) {}
+    ~PyAllowThreads()
+    {
+        PyEval_RestoreThread(_state);
+    }
+private:
+    PyThreadState* _state;
+};
+
+class PyEnsureGIL
+{
+public:
+    PyEnsureGIL() : _state(PyGILState_Ensure()) {}
+    ~PyEnsureGIL()
+    {
+        PyGILState_Release(_state);
+    }
+private:
+    PyGILState_STATE _state;
+};
+
+#define ERRWRAP2(expr) \
+try \
+{ \
+    PyAllowThreads allowThreads; \
+    expr; \
+} \
+catch (const cv::Exception &e) \
+{ \
+    PyErr_SetString(opencv_error, e.what()); \
+    return 0; \
+}
+
+using namespace cv;
+
+static PyObject* failmsgp(const char *fmt, ...)
+{
+  char str[1000];
+
+  va_list ap;
+  va_start(ap, fmt);
+  vsnprintf(str, sizeof(str), fmt, ap);
+  va_end(ap);
+
+  PyErr_SetString(PyExc_TypeError, str);
+  return 0;
+}
+
+class NumpyAllocator : public MatAllocator
+{
+public:
+    NumpyAllocator() { stdAllocator = Mat::getStdAllocator(); }
+    ~NumpyAllocator() {}
+
+    UMatData* allocate(PyObject* o, int dims, const int* sizes, int type, size_t* step) const
+    {
+        UMatData* u = new UMatData(this);
+        u->data = u->origdata = (uchar*)PyArray_DATA((PyArrayObject*) o);
+        npy_intp* _strides = PyArray_STRIDES((PyArrayObject*) o);
+        for( int i = 0; i < dims - 1; i++ )
+            step[i] = (size_t)_strides[i];
+        step[dims-1] = CV_ELEM_SIZE(type);
+        u->size = sizes[0]*step[0];
+        u->userdata = o;
+        return u;
+    }
+
+    UMatData* allocate(int dims0, const int* sizes, int type, void* data, size_t* step, AccessFlag flags, UMatUsageFlags usageFlags) const
+    {
+        if( data != 0 )
+        {
+            CV_Error(Error::StsAssert, "The data should normally be NULL!");
+            // probably this is safe to do in such extreme case
+            return stdAllocator->allocate(dims0, sizes, type, data, step, flags, usageFlags);
+        }
+        PyEnsureGIL gil;
+
+        int depth = CV_MAT_DEPTH(type);
+        int cn = CV_MAT_CN(type);
+        const int f = (int)(sizeof(size_t)/8);
+        int typenum = depth == CV_8U ? NPY_UBYTE : depth == CV_8S ? NPY_BYTE :
+        depth == CV_16U ? NPY_USHORT : depth == CV_16S ? NPY_SHORT :
+        depth == CV_32S ? NPY_INT : depth == CV_32F ? NPY_FLOAT :
+        depth == CV_64F ? NPY_DOUBLE : f*NPY_ULONGLONG + (f^1)*NPY_UINT;
+        int i, dims = dims0;
+        cv::AutoBuffer<npy_intp> _sizes(dims + 1);
+        for( i = 0; i < dims; i++ )
+            _sizes[i] = sizes[i];
+        if( cn > 1 )
+            _sizes[dims++] = cn;
+        PyObject* o = PyArray_SimpleNew(dims, _sizes, typenum);
+        if(!o)
+            CV_Error_(Error::StsError, ("The numpy array of typenum=%d, ndims=%d can not be created", typenum, dims));
+        return allocate(o, dims0, sizes, type, step);
+    }
+
+    bool allocate(UMatData* u, AccessFlag accessFlags, UMatUsageFlags usageFlags) const
+    {
+        return stdAllocator->allocate(u, accessFlags, usageFlags);
+    }
+
+    void deallocate(UMatData* u) const
+    {
+        if(u)
+        {
+            PyEnsureGIL gil;
+            PyObject* o = (PyObject*)u->userdata;
+            Py_XDECREF(o);
+            delete u;
+        }
+    }
+
+    const MatAllocator* stdAllocator;
+};
+
+NumpyAllocator g_numpyAllocator;
+
+
+template<typename T> static
+bool pyopencv_to(PyObject* obj, T& p, const char* name = "<unknown>");
+
+template<typename T> static
+PyObject* pyopencv_from(const T& src);
+
+enum { ARG_NONE = 0, ARG_MAT = 1, ARG_SCALAR = 2 };
+
+// special case, when the convertor needs full ArgInfo structure
+static bool pyopencv_to(PyObject* o, Mat& m, const ArgInfo info)
+{
+      // to avoid PyArray_Check() to crash even with valid array
+    do_numpy_import( );
+
+
+    bool allowND = true;
+    if(!o || o == Py_None)
+    {
+        if( !m.data )
+            m.allocator = &g_numpyAllocator;
+        return true;
+    }
+
+    if( PyInt_Check(o) )
+    {
+        double v[] = {(double)PyInt_AsLong((PyObject*)o), 0., 0., 0.};
+        m = Mat(4, 1, CV_64F, v).clone();
+        return true;
+    }
+    if( PyFloat_Check(o) )
+    {
+        double v[] = {PyFloat_AsDouble((PyObject*)o), 0., 0., 0.};
+        m = Mat(4, 1, CV_64F, v).clone();
+        return true;
+    }
+    if( PyTuple_Check(o) )
+    {
+        int i, sz = (int)PyTuple_Size((PyObject*)o);
+        m = Mat(sz, 1, CV_64F);
+        for( i = 0; i < sz; i++ )
+        {
+            PyObject* oi = PyTuple_GET_ITEM(o, i);
+            if( PyInt_Check(oi) )
+                m.at<double>(i) = (double)PyInt_AsLong(oi);
+            else if( PyFloat_Check(oi) )
+                m.at<double>(i) = (double)PyFloat_AsDouble(oi);
+            else
+            {
+                failmsg("%s is not a numerical tuple", info.name);
+                m.release();
+                return false;
+            }
+        }
+        return true;
+    }
+
+    if( !PyArray_Check(o) )
+    {
+        failmsg("%s is not a numpy array, neither a scalar", info.name);
+        return false;
+    }
+
+    PyArrayObject* oarr = (PyArrayObject*) o;
+
+    bool needcopy = false, needcast = false;
+    int typenum = PyArray_TYPE(oarr), new_typenum = typenum;
+    int type = typenum == NPY_UBYTE ? CV_8U :
+               typenum == NPY_BYTE ? CV_8S :
+               typenum == NPY_USHORT ? CV_16U :
+               typenum == NPY_SHORT ? CV_16S :
+               typenum == NPY_INT ? CV_32S :
+               typenum == NPY_INT32 ? CV_32S :
+               typenum == NPY_FLOAT ? CV_32F :
+               typenum == NPY_DOUBLE ? CV_64F : -1;
+
+    if( type < 0 )
+    {
+        if( typenum == NPY_INT64 || typenum == NPY_UINT64 || type == NPY_LONG )
+        {
+            needcopy = needcast = true;
+            new_typenum = NPY_INT;
+            type = CV_32S;
+        }
+        else
+        {
+            failmsg("%s data type = %d is not supported", info.name, typenum);
+            return false;
+        }
+    }
+
+#ifndef CV_MAX_DIM
+    const int CV_MAX_DIM = 32;
+#endif
+
+    int ndims = PyArray_NDIM(oarr);
+    if(ndims >= CV_MAX_DIM)
+    {
+        failmsg("%s dimensionality (=%d) is too high", info.name, ndims);
+        return false;
+    }
+
+    int size[CV_MAX_DIM+1];
+    size_t step[CV_MAX_DIM+1];
+    size_t elemsize = CV_ELEM_SIZE1(type);
+    const npy_intp* _sizes = PyArray_DIMS(oarr);
+    const npy_intp* _strides = PyArray_STRIDES(oarr);
+    bool ismultichannel = ndims == 3 && _sizes[2] <= CV_CN_MAX;
+
+    for( int i = ndims-1; i >= 0 && !needcopy; i-- )
+    {
+        // these checks handle cases of
+        //  a) multi-dimensional (ndims > 2) arrays, as well as simpler 1- and 2-dimensional cases
+        //  b) transposed arrays, where _strides[] elements go in non-descending order
+        //  c) flipped arrays, where some of _strides[] elements are negative
+        if( (i == ndims-1 && (size_t)_strides[i] != elemsize) ||
+            (i < ndims-1 && _strides[i] < _strides[i+1]) )
+            needcopy = true;
+    }
+
+    if( ismultichannel && _strides[1] != (npy_intp)elemsize*_sizes[2] )
+        needcopy = true;
+
+    if (needcopy)
+    {
+        if (info.outputarg)
+        {
+            failmsg("Layout of the output array %s is incompatible with cv::Mat (step[ndims-1] != elemsize or step[1] != elemsize*nchannels)", info.name);
+            return false;
+        }
+
+        if( needcast ) {
+            o = PyArray_Cast(oarr, new_typenum);
+            oarr = (PyArrayObject*) o;
+        }
+        else {
+            oarr = PyArray_GETCONTIGUOUS(oarr);
+            o = (PyObject*) oarr;
+        }
+
+        _strides = PyArray_STRIDES(oarr);
+    }
+
+    for(int i = 0; i < ndims; i++)
+    {
+        size[i] = (int)_sizes[i];
+        step[i] = (size_t)_strides[i];
+    }
+
+    // handle degenerate case
+    if( ndims == 0) {
+        size[ndims] = 1;
+        step[ndims] = elemsize;
+        ndims++;
+    }
+
+    if( ismultichannel )
+    {
+        ndims--;
+        type |= CV_MAKETYPE(0, size[2]);
+    }
+
+    if( ndims > 2 && !allowND )
+    {
+        failmsg("%s has more than 2 dimensions", info.name);
+        return false;
+    }
+
+    m = Mat(ndims, size, type, PyArray_DATA(oarr), step);
+    m.u = g_numpyAllocator.allocate(o, ndims, size, type, step);
+    m.addref();
+
+    if( !needcopy )
+    {
+        Py_INCREF(o);
+    }
+    m.allocator = &g_numpyAllocator;
+
+    return true;
+}
+
+template<>
+bool pyopencv_to(PyObject* o, Mat& m, const char* name)
+{
+    return pyopencv_to(o, m, ArgInfo(name, 0));
+}
+
+PyObject* pyopencv_from(const Mat& m)
+{
+    if( !m.data )
+        Py_RETURN_NONE;
+    Mat temp, *p = (Mat*)&m;
+    if(!p->u || p->allocator != &g_numpyAllocator)
+    {
+        temp.allocator = &g_numpyAllocator;
+        ERRWRAP2(m.copyTo(temp));
+        p = &temp;
+    }
+    PyObject* o = (PyObject*)p->u->userdata;
+    Py_INCREF(o);
+    return o;
+}
+
+int convert_to_CvMat2(const PyObject* o, cv::Mat& m)
+{
+    pyopencv_to(const_cast<PyObject*>(o), m, "unknown");
+    return 0;
+}
diff -urN vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/test/conversions.py cv_bridge.opencv4/test/conversions.py
--- vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/test/conversions.py	2018-04-30 19:54:22.000000000 +0200
+++ cv_bridge.opencv4/test/conversions.py	2020-04-29 14:54:18.115955703 +0200
@@ -61,6 +61,7 @@
                             original = np.uint8(np.random.randint(0, 255, size=(h, w)))
                         else:
                             original = np.uint8(np.random.randint(0, 255, size=(h, w, channels)))
+                        print(f)
                         compress_rosmsg = cvb_en.cv2_to_compressed_imgmsg(original, f)
                         newimg          = cvb_de.compressed_imgmsg_to_cv2(compress_rosmsg)
                         self.assert_(original.dtype == newimg.dtype)
diff -urN vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/test/enumerants.py cv_bridge.opencv4/test/enumerants.py
--- vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/test/enumerants.py	2018-04-30 19:54:22.000000000 +0200
+++ cv_bridge.opencv4/test/enumerants.py	2020-04-29 14:54:18.115955703 +0200
@@ -22,7 +22,7 @@
         bridge_ = CvBridge()
         cvim = bridge_.imgmsg_to_cv2(img_msg, "rgb8")
         import sys
-        self.assertRaises(sys.getrefcount(cvim) == 2)
+        self.assert_(sys.getrefcount(cvim) == 2)
 
         # A 3 channel image cannot be sent as an rgba8
         self.assertRaises(CvBridgeError, lambda: bridge_.cv2_to_imgmsg(cvim, "rgba8"))
@@ -31,9 +31,9 @@
         bridge_.cv2_to_imgmsg(cvim, "rgb8")
         bridge_.cv2_to_imgmsg(cvim, "bgr8")
 
-        self.assertRaises(getCvType("32FC4") == cv2.CV_8UC4)
-        self.assertRaises(getCvType("8UC1") == cv2.CV_8UC1)
-        self.assertRaises(getCvType("8U") == cv2.CV_8UC1)
+        self.assert_(getCvType("32FC4") == cv2.CV_32FC4)
+        self.assert_(getCvType("8UC1") == cv2.CV_8UC1)
+        self.assert_(getCvType("8U") == cv2.CV_8UC1)
 
     def test_numpy_types(self):
         import cv2
diff -urN vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/test/python_bindings.py cv_bridge.opencv4/test/python_bindings.py
--- vision_opencv-release-release-melodic-cv_bridge-1.13.0-0/test/python_bindings.py	2018-04-30 19:54:22.000000000 +0200
+++ cv_bridge.opencv4/test/python_bindings.py	2020-04-29 14:54:18.115955703 +0200
@@ -10,15 +10,15 @@
     height, width = label.shape[:2]
     label_value = 0
     grid_num_y, grid_num_x = 3, 4
-    for grid_row in xrange(grid_num_y):
+    for grid_row in range(grid_num_y):
         grid_size_y = height / grid_num_y
         min_y = grid_size_y * grid_row
         max_y = min_y + grid_size_y
-        for grid_col in xrange(grid_num_x):
+        for grid_col in range(grid_num_x):
             grid_size_x = width / grid_num_x
             min_x = grid_size_x * grid_col
             max_x = min_x + grid_size_x
-            label[min_y:max_y, min_x:max_x] = label_value
+            label[int(min_y):int(max_y), int(min_x):int(max_x)] = label_value
             label_value += 1
     label_viz = cv_bridge.cvtColorForDisplay(label, '32SC1', 'bgr8')
     assert_equal(label_viz.dtype, np.uint8)
